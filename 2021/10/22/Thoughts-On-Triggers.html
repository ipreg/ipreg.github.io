<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Thoughts on Triggers | IPreg’s Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Thoughts on Triggers" />
<meta name="author" content="ipreg" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A key goal of mine when I went into “A Town Unfiltered” was to make it as dynamic as possible. The original game was running into technical debt where every change had to be accounted for in long sections of if-else statements. This lead to a large list of “story” variables which kept track of the game state and different situations had to ensure what combination of story variables were what values to lead the player into the correct conversation. This is really bad game design on the development side, while it initially allows for quick prototyping and iteration due to the simplicity of the code, for anything more complex than a game jam game it will become a ball and chain where it slows development and to fix becomes making a whole new game. This is what I suspect occurred with “yandere simulator” and is happening to “A Town Uncovered”, though the story events are disparate enough that this sort of design kind of works if you are essentially making a bunch of small games inside a big one, which might prevent “A Town Uncovered” from falling into a similar trap (Having the resources to pay for programmers to spend the time to trudge through it helps too)." />
<meta property="og:description" content="A key goal of mine when I went into “A Town Unfiltered” was to make it as dynamic as possible. The original game was running into technical debt where every change had to be accounted for in long sections of if-else statements. This lead to a large list of “story” variables which kept track of the game state and different situations had to ensure what combination of story variables were what values to lead the player into the correct conversation. This is really bad game design on the development side, while it initially allows for quick prototyping and iteration due to the simplicity of the code, for anything more complex than a game jam game it will become a ball and chain where it slows development and to fix becomes making a whole new game. This is what I suspect occurred with “yandere simulator” and is happening to “A Town Uncovered”, though the story events are disparate enough that this sort of design kind of works if you are essentially making a bunch of small games inside a big one, which might prevent “A Town Uncovered” from falling into a similar trap (Having the resources to pay for programmers to spend the time to trudge through it helps too)." />
<link rel="canonical" href="https://ipreg.github.io/2021/10/22/Thoughts-On-Triggers.html" />
<meta property="og:url" content="https://ipreg.github.io/2021/10/22/Thoughts-On-Triggers.html" />
<meta property="og:site_name" content="IPreg’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-10-22T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Thoughts on Triggers" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"https://ipreg.github.io/2021/10/22/Thoughts-On-Triggers.html","headline":"Thoughts on Triggers","dateModified":"2021-10-22T00:00:00-04:00","datePublished":"2021-10-22T00:00:00-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://ipreg.github.io/2021/10/22/Thoughts-On-Triggers.html"},"author":{"@type":"Person","name":"ipreg"},"description":"A key goal of mine when I went into “A Town Unfiltered” was to make it as dynamic as possible. The original game was running into technical debt where every change had to be accounted for in long sections of if-else statements. This lead to a large list of “story” variables which kept track of the game state and different situations had to ensure what combination of story variables were what values to lead the player into the correct conversation. This is really bad game design on the development side, while it initially allows for quick prototyping and iteration due to the simplicity of the code, for anything more complex than a game jam game it will become a ball and chain where it slows development and to fix becomes making a whole new game. This is what I suspect occurred with “yandere simulator” and is happening to “A Town Uncovered”, though the story events are disparate enough that this sort of design kind of works if you are essentially making a bunch of small games inside a big one, which might prevent “A Town Uncovered” from falling into a similar trap (Having the resources to pay for programmers to spend the time to trudge through it helps too).","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://ipreg.github.io/feed.xml" title="IPreg's Blog" />
</head>
<body><header class="site-header">

  <div class="wrapper">
<a class="site-title" rel="author" href="/">IPreg's Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger">
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewbox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav>
</div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Thoughts on Triggers</h1>
    <p class="post-meta"><time class="dt-published" datetime="2021-10-22T00:00:00-04:00" itemprop="datePublished">
        Oct 22, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>A key goal of mine when I went into “A Town Unfiltered” was to make it as dynamic as possible. The original game was running into technical debt where every change had to be accounted for in long sections of if-else statements. This lead to a large list of “story” variables which kept track of the game state and different situations had to ensure what combination of story variables were what values to lead the player into the correct conversation. This is really bad game design on the development side, while it initially allows for quick prototyping and iteration due to the simplicity of the code, for anything more complex than a game jam game it will become a ball and chain where it slows development and to fix becomes making a whole new game. This is what I suspect occurred with “yandere simulator” and is happening to “A Town Uncovered”, though the story events are disparate enough that this sort of design kind of works if you are essentially making a bunch of small games inside a big one, which might prevent “A Town Uncovered” from falling into a similar trap (Having the resources to pay for programmers to spend the time to trudge through it helps too).
<!--more--></p>
<h3 id="introduction">Introduction</h3>
<p>To say this is unacceptable to me is a vast understatement, my honor as a programmer is on the line and my first step was to completely throw out all the code that was written except the location screens (even then I ended up massively changing them). I used this project as a way to hone my skills in python and I have become a much, much better programmer for it; the hours and hours I spent writing and rewriting my code to be better and more dynamic is something I am quite proud of. I could literally spend days discussing every single system I put into this thing, and now that I have this blog, I just might.</p>

<h3 id="the-story-machine">The Story Machine</h3>
<p>To start off the overall structure of the game is that there is a “god object” which all objects submit changes to the game’s state and read the game’s state from. I know that “god objects” are generally looked down upon in game-dev, but I have a reason for this design choice. Ren’Py has some very funny ideas about what a local and global variable means, as well as how accessing variables and setting variables works. This comes from the fact that Ren’Py messes with python itself to accomplish what it does, but this also can lead to unexpected behavior when you are doing as much in python as I am. I needed a way to ensure that “global/local story variables” and “global/local making-the-game-go variables” didn’t mix or influence each other. I solved this with a “god object” which stores all story variables as well as all the core game objects which need to manipulate those variables. Now of course, there are a couple <code class="language-plaintext highlighter-rouge">global storyMachine</code> (<code class="language-plaintext highlighter-rouge">storyMachine</code> is the god object) floating around, but overall I have segregated functionalities into classes as much as I could and prevent the use of global variables as much as possible. This has greatly helped in debugging as well as the python stack traces usually lead directly to the problem.</p>

<h3 id="triggers-finally-getting-to-the-title">Triggers, finally getting to the title</h3>
<p>So how does this all fit together with what I actually want to discuss here, triggers? Well, how does one perform state checks to see if the game should do something at a given time when nothing is global or set in stone? Easy, you create a family of <code class="language-plaintext highlighter-rouge">Trigger</code> objects and classes; anything in the game (and not during a conversation) which needs to perform a state check is given a <code class="language-plaintext highlighter-rouge">Trigger</code> object and if the <code class="language-plaintext highlighter-rouge">Trigger</code> object’s conditions are satisfied it turns on.</p>

<p>As an example, let’s say I want to check if a Map Button should be active based on a variable called <code class="language-plaintext highlighter-rouge">story_var</code>, if I was using the style of the original you would do something like this:
<strong>map_locations.rpy</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>label some_location_map:
  if story_var &gt; 10:
    jump some_location
  else:
    pov "I shouldn't be going there right now"
    jump map
</code></pre></div></div>
<p>But using my trigger system that exact same check looks like this:
<strong>act_1_setup.rpy</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dont_go_right_now = Trigger(LT, "story_var", 10, msg="I shouldn't be going there right now")
$ storyMachine.map.add_disable_trigger(dont_go_right_now, "some_location")
</code></pre></div></div>
<p>To break down what my code is saying: <code class="language-plaintext highlighter-rouge">LT</code> is the “Less Than” function, <code class="language-plaintext highlighter-rouge">story_var</code> is the name of the state we want to check, <code class="language-plaintext highlighter-rouge">10</code> is the value to check against, and <code class="language-plaintext highlighter-rouge">msg</code> is some metadata used by the <code class="language-plaintext highlighter-rouge">map</code> object to set the disabled message for that button as all triggers can have any amount of metadata attached to them.
It definitely is more complicated, so what are the benefits? Well, lets say I now need to add an additional condition to prevent the main character from free-roaming based on <code class="language-plaintext highlighter-rouge">story_var_2</code> and a conversation, what would that look like?</p>

<p><strong>map_locations.rpy</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>label some_location_map:
  if story_var &gt; 10 and not talked_to_polly:
    jump some_location
  elif story_var_2 &gt; 20 and talked_to_polly:
    pov "I should be going to the lake"
    jump map
  elif talked_to_polly:
    jump some_location
  else:
    pov "I shouldn't be going there right now"
    jump map
</code></pre></div></div>
<p>But using my trigger system one way to perform that exact same check would look like this:
<strong>act_1_setup.rpy</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dont_go_right_now = Trigger(LT, "story_var", 10, msg="I shouldn't be going there right now")
$ storyMachine.map.add_disable_trigger(dont_go_right_now, "some_location")
</code></pre></div></div>
<p><strong>talk_to_polly.rpy</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pol "You need to go to the lake after talking with Alice"
$ go_to_lake = Trigger(GT, "story_var_2", 20, msg="I should go to the Lake")
$ storyMachine.map.add_enable_trigger(go_to_lake, "lake")
</code></pre></div></div>

<p>This example should show the full benefits of the trigger system. Triggers can be created and added anywhere, so I if I need to change the behavior of something halfway through the game, I can easily do it and don’t need to check if previous events occurred.  The individual classes and functions which use them can decide based on context how to use them, so in this case <code class="language-plaintext highlighter-rouge">add_disable_trigger</code> prevents a button from being used, but <code class="language-plaintext highlighter-rouge">add_enable_trigger</code> prevents <em>all other non-enabled buttons</em> from being used. Finally, I don’t need to worry about every permutation of the game state, or make super generic repsonses; I can control just the specific parts I want without too much trouble.</p>

<h3 id="compound-triggers">Compound Triggers</h3>

<p>So the specifics of how triggers work is based around <code class="language-plaintext highlighter-rouge">renpy.partial</code> and <code class="language-plaintext highlighter-rouge">renpy.curry</code>; these allow for turning python functions into Ren’Py objects. Those variables <code class="language-plaintext highlighter-rouge">LT</code> and <code class="language-plaintext highlighter-rouge">GT</code> are not strings which the function then looks up, those <strong><em>are</em></strong> the less-than and greater-than functions, which the trigger just throws the values into and returns the result whenever checked. These are essentially portable and dynamic if statements. Unlike if statements though, these can be removed, swapped, created, and changed on the fly during the game. But, if these are like if statements, can we combine them using <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">not</code>, and <code class="language-plaintext highlighter-rouge">or</code>?</p>

<p>Yes, using the power of “metaclasses”, a “dunder function” builder function, a “MixIn” super class, logic operator classes, and compound classes, I was able to create a system which allows for these kind of things where logic and triggers can be combined effortlessly:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ GTE = GT | EQ
$ NQ = ~EQ
$ stop_criminal_trigger = Trigger(GT, "star_level", 3) | (PlayerInfoTrigger(GTE, "money", 1e6) &amp; HourTrigger(NQ, Hour.NIGHT))
</code></pre></div></div>

<p>But that is a story for another time.</p>

  </div>
<a class="u-url" href="/2021/10/22/Thoughts-On-Triggers.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">ipreg</li>
          
        </ul>
      </div>
      <div class="footer-col">
        <p>A place for my thoughts
</p>
      </div>
    </div>

    <div class="social-links">
<ul class="social-media-list"><li><a rel="noopener noreferrer" href="https://github.com/ipreg" title="ipreg" target="_blank"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>

<script src=”https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=”MathJax-script” async src=”https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>